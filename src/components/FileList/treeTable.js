// Copyright (c) Microsoft Corporation and others. Licensed under the MIT license.
// SPDX-License-Identifier: MIT
import React from 'react'
import ThCustomComponent from './ThCustomComponent'
import TrCustomComponent from './TrCustomComponent'
import TdCustomComponent from './TdCustomComponent'
import PivotCustomComponent from './PivotCustomComponent'

/**
 * TreeTable HOC Component
 * This is a custom implementation based on react-table TreeTable HOC
 * The purpose is to provide the data to the renderer, excluding any "undefined"
 * row generated by the Pivot grouping function
 *
 * It renders custom components instead the default of ReactTable
 *
 */
export default Component => {
  const wrapper = class RTTreeTable extends React.Component {
    constructor(props) {
      super(props)
      this.getWrappedInstance.bind(this)
      this.getTrProps.bind(this)
      this.getSubrows.bind(this)
    }

    // this is so we can expose the underlying ReactTable to get at the sortedData for selectAll
    getWrappedInstance = () => {
      if (!this.wrappedInstance) console.warn('RTTreeTable - No wrapped instance')
      if (this.wrappedInstance.getWrappedInstance) return this.wrappedInstance.getWrappedInstance()
      else return this.wrappedInstance
    }

    /**
     * This is the custom implementation where each subRow with _pivotVal "undefined" is parsed
     * in any of his _subRows childs, until find the first _pivotVal !== "undefined"
     *
     * Once the object has been found, than it will returned to the first parent,
     * updating the value of _nestingLevel as well
     *
     */
    getSubrows = subRows => {
      subRows &&
        subRows.forEach((subRow, index) => {
          if (subRow._pivotVal === 'undefined' && subRow._subRows) {
            let items = this.getSubrows(subRow._subRows)
            items.forEach(item => {
              item._pivotID = subRow._pivotID
              item._nestingLevel = subRow._nestingLevel

              subRows.push(item)
            })
            subRows.splice(index, 1)
          }
        })
      return subRows
    }

    getTrProps = (state, ri, ci, instance) => {
      return {
        ri,
        expanded: ri && ri.level === 0 && ri.row._pivotVal === 'undefined' ? 'true' : 'false',
        style: {
          padding: ri && ri.level === 0 && ri.row._pivotVal === 'undefined' ? '0px' : null
        }
      }
    }

    render() {
      const { columns, treeTableIndent, ...rest } = this.props
      const { getTrProps } = this

      const extra = {
        columns: columns.map(col => {
          let column = col
          if (rest.pivotBy && rest.pivotBy.includes(col.accessor)) {
            column = {
              accessor: col.accessor,
              Header: col.accessor === 'name' ? 'Name' : '',
              show: true,
              resizable: false,
              Pivot: cellInfo => <PivotCustomComponent {...cellInfo} defaultProps={Component.defaultProps} />
            }
            if (col.accessor !== 'name') column.width = `${treeTableIndent}px`
            column.style = { border: '0px' }
          }
          return column
        }),
        ThComponent: props => <ThCustomComponent {...props} defaultProps={Component.defaultProps} />,
        TdComponent: props => <TdCustomComponent {...props} defaultProps={Component.defaultProps} />,
        TrComponent: props => (
          <TrCustomComponent
            {...props}
            defaultProps={Component.defaultProps}
            treeTableIndent={treeTableIndent}
            getSubrows={this.getSubrows}
          />
        ),
        getTrProps
      }

      return <Component {...rest} {...extra} ref={r => (this.wrappedInstance = r)} />
    }
  }
  wrapper.displayName = 'RTTreeTable'
  wrapper.defaultProps = {
    treeTableIndent: 2
  }

  return wrapper
}
